<div id="scroll-progress" class="scroll-progress"></div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
<script src="/assets/js/theme-toggle.js"></script>

<style>
/* CRITICAL FIX: Callout text colors - override everything */
/* Light mode */
.callout *,
.callout .callout-title-container,
.callout .callout-header,
.callout .callout-body,
.callout p,
.callout div,
.callout span,
.callout strong,
.callout em {
  color: #000000 !important;
}

/* Dark mode */
[data-bs-theme="dark"] .callout *,
[data-bs-theme="dark"] .callout .callout-title-container,
[data-bs-theme="dark"] .callout .callout-header,
[data-bs-theme="dark"] .callout .callout-body,
[data-bs-theme="dark"] .callout p,
[data-bs-theme="dark"] .callout div,
[data-bs-theme="dark"] .callout span,
[data-bs-theme="dark"] .callout strong,
[data-bs-theme="dark"] .callout em {
  color: #ffffff !important;
}
</style>

<footer class="site-footer">
  <div class="site-footer-inner">
    <span id="copyright-year"></span> Joseph Frimpong · Built with <a href="https://quarto.org" target="_blank" rel="noopener">Quarto</a> · Hosted on <a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>
  </div>
</footer>

<script>
  (function() {
    const el = document.getElementById('copyright-year');
    if (el) {
      el.textContent = `© ${new Date().getFullYear()}`;
    }
  })();
</script>
<script>
  (function() {
    const bar = document.getElementById('scroll-progress');
    if (!bar) return;
    const update = () => {
      const doc = document.documentElement;
      const body = document.body;
      const scrollTop = doc.scrollTop || body.scrollTop;
      const height = doc.scrollHeight - doc.clientHeight;
      const progress = height > 0 ? (scrollTop / height) * 100 : 0;
      bar.style.width = progress + '%';
    };
    window.addEventListener('scroll', update, { passive: true });
    window.addEventListener('load', update);
  })();
</script>
<script>
  (function() {
    const body = document.body;
    if (!body) return;

    const MIN_LINES = 10;

    const enhanceBlock = (container, codeEl) => {
      if (!container || !codeEl) return;
      if (container.dataset.codeEnhanced === 'true') return;
      if (container.closest('details.code-block-collapsible')) return;

      const text = codeEl.textContent.replace(/\s+$/, '');
      const lines = text ? text.split(/\r?\n/).length : 0;
      if (lines <= MIN_LINES) {
        container.dataset.codeEnhanced = 'true';
        return;
      }

      const parent = container.parentElement;
      if (!parent) return;

      const details = document.createElement('details');
      details.className = 'code-block-collapsible';

      const summary = document.createElement('summary');
      summary.className = 'code-block-summary';

      const summaryText = document.createElement('span');
      summaryText.className = 'code-block-summary-text';
      summaryText.textContent = `Show code (${lines} lines)`;

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'code-copy-btn';
      copyBtn.textContent = 'Copy';

      summary.appendChild(summaryText);
      summary.appendChild(copyBtn);
      details.appendChild(summary);

      const bodyWrapper = document.createElement('div');
      bodyWrapper.className = 'code-collapse-body';

      parent.insertBefore(details, container);
      bodyWrapper.appendChild(container);
      details.appendChild(bodyWrapper);

      details.addEventListener('toggle', () => {
        if (details.open) {
          summaryText.textContent = `Hide code (${lines} lines)`;
          details.classList.add('open');
        } else {
          summaryText.textContent = `Show code (${lines} lines)`;
          details.classList.remove('open');
        }
      });

      copyBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (!navigator.clipboard) {
          copyBtn.textContent = 'Not supported';
          setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1800);
          return;
        }
        navigator.clipboard.writeText(codeEl.textContent).then(() => {
          copyBtn.textContent = 'Copied!';
          copyBtn.classList.add('copied');
          setTimeout(() => {
            copyBtn.textContent = 'Copy';
            copyBtn.classList.remove('copied');
          }, 1800);
        }).catch(() => {
          copyBtn.textContent = 'Retry';
          copyBtn.classList.add('error');
          setTimeout(() => {
            copyBtn.textContent = 'Copy';
            copyBtn.classList.remove('error');
          }, 1800);
        });
      });

      container.dataset.codeEnhanced = 'true';
    };

    const enhanceAll = () => {
      document.querySelectorAll('div.sourceCode').forEach((container) => {
        const codeEl = container.querySelector('code');
        enhanceBlock(container, codeEl);
      });

      document.querySelectorAll('pre').forEach((pre) => {
        if (pre.closest('div.sourceCode')) return;
        const codeEl = pre.querySelector('code') || pre;
        enhanceBlock(pre, codeEl);
      });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', enhanceAll);
    } else {
      enhanceAll();
    }
  })();
</script>
<!-- Dock magnification disabled to avoid overlap/fusion of icons -->
<script>
  // Layout-safe dock magnification for tools icons
  (function() {
    const row = document.querySelector('.tools-row');
    if (!row) return;
    const icons = Array.from(row.querySelectorAll('img'));
    if (!icons.length) return;

    let raf = null;
    let mouseX = 0;
    let active = false;
    const influence = 80;  // smaller radius so neighbors barely move
    const maxBoost = 0.9;  // strong center zoom, less global motion

    // capture base sizes once
    const base = new Map();
    function captureBase() {
      icons.forEach((img) => {
        const cs = getComputedStyle(img);
        const w = parseFloat(cs.width) || 45;
        const h = parseFloat(cs.height) || 45;
        const bs = parseFloat(cs.getPropertyValue('--icon-base-scale')) || 1;
        base.set(img, { w, h, bs });
        // reset inline sizes
        img.style.width = w + 'px';
        img.style.height = h + 'px';
      });
    }
    captureBase();

    function update() {
      raf = null;
      const rowRect = row.getBoundingClientRect();
      const rowHeight = rowRect.height || 110;
      icons.forEach((img) => {
        const b = base.get(img);
        if (!b) return;
        const rect = img.getBoundingClientRect();
        const center = rect.left + rect.width / 2;
        const d = Math.abs(mouseX - center);
        // smooth gaussian-like falloff with threshold to avoid "elastic" feel
        const t = Math.exp(-((d / influence) ** 2));
        const neighborCutoff = 0.28; // below this, no growth at all
        const eff = active && t > neighborCutoff ? (t - neighborCutoff) / (1 - neighborCutoff) : 0;
        let scale = b.bs * (1 + maxBoost * eff);
        // clamp maximum to avoid exceeding row height (keep top/bottom fixed)
        const maxByHeight = (rowHeight - 6) / b.h;
        const maxScale = Math.min(b.bs * 2.0, maxByHeight);
        if (scale > maxScale) scale = maxScale;
        img.style.width = (b.w * scale).toFixed(2) + 'px';
        img.style.height = (b.h * scale).toFixed(2) + 'px';
        img.style.zIndex = String(Math.round(scale * 100));
      });
    }

    function onMove(e) {
      mouseX = e.clientX;
      if (!raf) raf = requestAnimationFrame(update);
    }
    function onEnter(e) { active = true; onMove(e); }
    function onLeave() {
      active = false;
      // reset sizes to base
      icons.forEach((img) => {
        const b = base.get(img);
        if (b) {
          img.style.width = b.w + 'px';
          img.style.height = b.h + 'px';
          img.style.zIndex = '1';
        }
      });
      // keep container height steady (CSS min-height handles this)
    }

    row.addEventListener('mousemove', onMove);
    row.addEventListener('mouseenter', onEnter);
    row.addEventListener('mouseleave', onLeave);

    // Recompute base sizes on resize (e.g., responsive breakpoints)
    window.addEventListener('resize', () => {
      captureBase();
      update();
    });
  })();
</script>
